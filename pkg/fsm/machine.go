package fsm

import (
	"context"
	"errors"

	"github.com/google/uuid"
	"go.uber.org/zap"

	"gitlab.com/gobl/gobl/pkg/logger"
)

// FSM is the interface that represents a state machine
type FSM interface {
	// ID returns the unique id of the state machine
	ID() uuid.UUID
	// Name returns the name assigned to the state machine
	Name() string
	// CurrentState returns the current state of the state machine
	CurrentState() State
	// CurrentDescription returns a description of the current state of the machine
	CurrentDescription() string
	// Run executes the state machine
	Run(context.Context, <-chan Event, func() error) error
}

type Machine struct {
	id      uuid.UUID
	name    string
	current State
	errCh   chan error
	hasRun  bool
}

// New creates a state machine with the given initial state
// and a channel where any errors generated by the state machine will
// be published
//
//nolint:gocritic
func New(id uuid.UUID, name string, init State) (*Machine, chan error) {
	m := new(Machine)
	m.id = id
	m.name = name
	m.current = init
	m.hasRun = false
	errCh := make(chan error)
	m.errCh = errCh

	return m, errCh
}

// ID returns the unique ID of the state machine
func (m *Machine) ID() uuid.UUID {
	return m.id
}

// Name returns a user friendly name of the state machine
func (m *Machine) Name() string {
	return m.name
}

// CurrentState returns the current state of the machine
func (m *Machine) CurrentState() State {
	return m.current
}

// CurrentDescription returns a description of the current state of the machine
func (m *Machine) CurrentDescription() string {
	return m.current.Description()
}

// Run executes the state machine with the given context
// A state machine can only be run once, once the state machine has started its run, it will
// return an error if Run is called again.
// Run takes an event channel for events to be passed to the state machine, if the events channel
// is closed, the state machine will exit.
// Run will close the error channel automatically when processing has been completed
func (m *Machine) Run(ctx context.Context, eventCh <-chan Event, cleanup func() error) error {
	if m.hasRun {
		return errors.New("state machine has already been run and cannot be re-run, you need to create a new state machine")
	}

	m.hasRun = true

	l := logger.Logger()

	defer close(m.errCh)

	for {
		select {
		case <-ctx.Done():
			l.Warn("Context has ended, stopping state machine")
			return cleanup()
		case event, ok := <-eventCh:
			if !ok {
				l.Warn("Incoming event channel has been closed, terminating state machine")
				return nil
			}

			l.Info("Received event",
				zap.String("name", event.Name()),
				zap.String("source", event.Source()),
				zap.String("id", event.ID().String()),
				zap.String("timestamp", TimestampToString(event.Timestamp())),
			)

			err := m.current.Execute(event)

			if err != nil {
				l.Error("Processing event resulted in error", zap.Error(err))
				m.errCh <- err
				continue
			}

			next := m.current.Next()
			if next == nil {
				return nil
			}

			if next.ID() != m.current.ID() {
				l.Info("State machine transitioning to new state",
					zap.String("current", m.current.Description()),
					zap.String("next", next.Description()),
				)
			}

			m.current = next
		}
	}
}
